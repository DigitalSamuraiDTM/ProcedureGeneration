package com.digitalsamurai.math.interpolators.dimensionals.one

/**
 * Кубическая интерполяция
 * based on (https://habr.com/ru/articles/111402/)
 * Позволяет получить интерполяцию, используя функцию полинома трейтьей степени
 * y = ax^3+bx^2+cx+d
 *
 * Производная полинома является функцией параболы
 * y' = 3ax^2+2bx+c
 *
 * Отсюда получаем:
 * f(0) = d
 * f(1) = a+b+c+d
 * f'(0) = c
 * f'(1) = 3a+2b+c
 *
 * Можно записать также (преобразования можно посчитать если захотеть):
 * a = 2f(0)-2f(1)+f'(0)+f'(1)
 * b = -3f(0)+3f(1)-2f'(0)-f'(1)
 * c = f'(0)
 * d = f(0)
 *
 * Для расчета интерполяции нам надо 4 точки, расположенных на координатах Х -1,0,1,2
 * ## Почему именно четыре точки: -1, 0, 1, 2
 * Построить B-сплайн, то есть сплайн с 4 интервалами, необходимо задать 4 точки (что логично)
 * Используя три точки для поиска функции интерполяции мы получим квадратичную интерполяцию
 * Формула: y = y1 * ((x-x2)*(x-x3)) / ((x1-x2)*(x1-x3))
 * Используются конкретно эти значения, чтобы было просто проще проводить вычисления, так как по факту по итогу, если интерполяцию надо продолжить далее
 * то необходимо просто наслаивать значения одной интерполяции с частями вводных данных следующей итерации интерполяции
 * p0 = Point(-1,yM1)
 * p1 = Point(0,y0)
 * p2 = Point(1,y1)
 * p3 = Point(2,y2)
 * f(0) = p1
 * f(1) = p2
 * f'(0) = (p2 - p0) / 2
 * f'(1) = (p3 - p1) / 2
 *
 */
internal fun cubicInterpolation(
    entryX: Float,
    yM1: Float,
    y0: Float,
    y1: Float,
    y2: Float,
): Float {
    val a = entryX * entryX * entryX * ((y0 - y1) / 2 + (y2 - yM1) / 6)
    val b = entryX * entryX * (yM1 + y1 - 2 * y0) / 2
    val c = entryX * (y1 - (2 * yM1 + 3 * y0 + y2) / 6)
    val d = y0
    return a + b + c + d
}

//TODO проверить на входных данных